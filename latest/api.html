<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ReactiveBasics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ReactiveBasics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ReactiveBasics-API-1" href="#ReactiveBasics-API-1">ReactiveBasics API</a></h1><ul><li><a href="api.html#ReactiveBasics.Signal"><code>ReactiveBasics.Signal</code></a></li><li><a href="api.html#Base.Iterators.zip-Tuple{ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>Base.Iterators.zip</code></a></li><li><a href="api.html#Base.asyncmap-Tuple{Any,Any,ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>Base.asyncmap</code></a></li><li><a href="api.html#Base.filter-Union{Tuple{T}, Tuple{Any,T,ReactiveBasics.Signal{T}}} where T"><code>Base.filter</code></a></li><li><a href="api.html#Base.map-Tuple{Any,ReactiveBasics.Signal}"><code>Base.map</code></a></li><li><a href="api.html#Base.merge-Tuple{ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>Base.merge</code></a></li><li><a href="api.html#Base.push!-Tuple{ReactiveBasics.Signal,Any}"><code>Base.push!</code></a></li><li><a href="api.html#ReactiveBasics.bind!"><code>ReactiveBasics.bind!</code></a></li><li><a href="api.html#ReactiveBasics.droprepeats-Union{Tuple{ReactiveBasics.Signal{T}}, Tuple{T}} where T"><code>ReactiveBasics.droprepeats</code></a></li><li><a href="api.html#ReactiveBasics.filterwhen-Union{Tuple{T}, Tuple{ReactiveBasics.Signal{Bool},T,ReactiveBasics.Signal{T}}} where T"><code>ReactiveBasics.filterwhen</code></a></li><li><a href="api.html#ReactiveBasics.flatmap-Tuple{Any,ReactiveBasics.Signal}"><code>ReactiveBasics.flatmap</code></a></li><li><a href="api.html#ReactiveBasics.flatten-Tuple{ReactiveBasics.Signal}"><code>ReactiveBasics.flatten</code></a></li><li><a href="api.html#ReactiveBasics.foldp-Tuple{Any,Any,Vararg{ReactiveBasics.Signal,N} where N}"><code>ReactiveBasics.foldp</code></a></li><li><a href="api.html#ReactiveBasics.preserve-Tuple{ReactiveBasics.Signal}"><code>ReactiveBasics.preserve</code></a></li><li><a href="api.html#ReactiveBasics.previous"><code>ReactiveBasics.previous</code></a></li><li><a href="api.html#ReactiveBasics.sampleon-Union{Tuple{T}, Tuple{ReactiveBasics.Signal,ReactiveBasics.Signal{T}}} where T"><code>ReactiveBasics.sampleon</code></a></li><li><a href="api.html#ReactiveBasics.subscribe!-Tuple{Any,ReactiveBasics.Signal}"><code>ReactiveBasics.subscribe!</code></a></li><li><a href="api.html#ReactiveBasics.unsubscribe!-Tuple{Any,ReactiveBasics.Signal}"><code>ReactiveBasics.unsubscribe!</code></a></li><li><a href="api.html#ReactiveBasics.value-Tuple{ReactiveBasics.Signal}"><code>ReactiveBasics.value</code></a></li><li><a href="api.html#ReactiveBasics.zipmap-Tuple{Any,ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>ReactiveBasics.zipmap</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.Signal" href="#ReactiveBasics.Signal"><code>ReactiveBasics.Signal</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A <code>Signal</code> is value that will contain a value in the future. The value of the Signal can change at any time.</p><p>Use <code>map</code> to derive new Signals, <code>subscribe!</code> to subscribe to updates of a Signal, and <code>push!</code> to update the current value of a Signal. <code>value</code> returns the current value of a Signal. The type of the Signal can optionally be set by the first parameter. Otherwise it will default to the type of the initial value.</p><pre><code class="language-julia">text = Signal(&quot;&quot;)

text2 = map(s -&gt; &quot;Bye $s&quot;, text)

subscribe!(text) do s
    println(&quot;Hello $s&quot;)
end

push!(text, &quot;world&quot;)

value(text)
value(text2)

float_number = Signal(Float64, 1) # Optionally set the type of the Signal</code></pre></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L16-L42">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.bind!" href="#ReactiveBasics.bind!"><code>ReactiveBasics.bind!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">bind!(a, b)
bind!(a, b, twoway)
</code></pre><p>For every update to <code>b</code> also update <code>a</code> with the same value and, if <code>twoway</code> is true, vice-versa. Initially update <code>a</code> with the value in <code>b</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L293">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.droprepeats-Union{Tuple{ReactiveBasics.Signal{T}}, Tuple{T}} where T" href="#ReactiveBasics.droprepeats-Union{Tuple{ReactiveBasics.Signal{T}}, Tuple{T}} where T"><code>ReactiveBasics.droprepeats</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">droprepeats(input)
</code></pre><p>Drop updates to <code>input</code> whenever the new value is the same as the previous value of the Signal.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L308">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.filterwhen-Union{Tuple{T}, Tuple{ReactiveBasics.Signal{Bool},T,ReactiveBasics.Signal{T}}} where T" href="#ReactiveBasics.filterwhen-Union{Tuple{T}, Tuple{ReactiveBasics.Signal{Bool},T,ReactiveBasics.Signal{T}}} where T"><code>ReactiveBasics.filterwhen</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">filterwhen(predicate, default, u)
</code></pre><p>Keep updates to <code>u</code> only when <code>predicate</code> is true. If <code>predicate</code> is false initially, the specified <code>default</code> value is used.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L242">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.flatmap-Tuple{Any,ReactiveBasics.Signal}" href="#ReactiveBasics.flatmap-Tuple{Any,ReactiveBasics.Signal}"><code>ReactiveBasics.flatmap</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">flatmap(f, input; init, typ)
</code></pre><p>Transform the Signal into another Signal using a function. It&#39;s like <code>map</code>, but it&#39;s meant for functions that return <code>Signal</code>s. The initial value of the output Signal can optionally be set via <code>init</code>. Otherwise it defaults to <code>f(input.value).value</code>, where f is the passed function and input is the passed Signal of Signals. The type of the output Signal can optionally be set via <code>typ</code>. Otherwise it defaults to the type of the initial value.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L100">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.flatten-Tuple{ReactiveBasics.Signal}" href="#ReactiveBasics.flatten-Tuple{ReactiveBasics.Signal}"><code>ReactiveBasics.flatten</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">flatten(input)
</code></pre><p>Flatten a Signal of Signals into a Signal which holds the value of the current Signal.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L271">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.foldp-Tuple{Any,Any,Vararg{ReactiveBasics.Signal,N} where N}" href="#ReactiveBasics.foldp-Tuple{Any,Any,Vararg{ReactiveBasics.Signal,N} where N}"><code>ReactiveBasics.foldp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">foldp(f, v0, us)
</code></pre><p>Fold/map over past values. The first argument to the function <code>f</code> is an accumulated value that the function can operate over, and the second is the current value coming in. <code>v0</code> is the initial value of the accumulated value.</p><pre><code class="language-none">a = Signal(2)
# accumulate sums coming in from a, starting at zero
b = foldp(+, 0, a) # b == 2
push!(a, 2)        # b == 4
push!(a, 3)        # b == 7</code></pre></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L214">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.preserve-Tuple{ReactiveBasics.Signal}" href="#ReactiveBasics.preserve-Tuple{ReactiveBasics.Signal}"><code>ReactiveBasics.preserve</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">preserve(x)
</code></pre><p>For compatibility with Reactive. It just returns the original Signal because this isn&#39;t needed with direct <code>push!</code> updates.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L346">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.previous" href="#ReactiveBasics.previous"><code>ReactiveBasics.previous</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">previous(input)
previous(input, default)
</code></pre><p>Create a Signal which holds the previous value of <code>input</code>. You can optionally specify a different initial value.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L320">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.sampleon-Union{Tuple{T}, Tuple{ReactiveBasics.Signal,ReactiveBasics.Signal{T}}} where T" href="#ReactiveBasics.sampleon-Union{Tuple{T}, Tuple{ReactiveBasics.Signal,ReactiveBasics.Signal{T}}} where T"><code>ReactiveBasics.sampleon</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">sampleon(a, b)
</code></pre><p>Sample the value of <code>b</code> whenever <code>a</code> updates.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L335">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.subscribe!-Tuple{Any,ReactiveBasics.Signal}" href="#ReactiveBasics.subscribe!-Tuple{Any,ReactiveBasics.Signal}"><code>ReactiveBasics.subscribe!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">subscribe!(f, u)
</code></pre><p>Subscribe to the changes of this Signal. Every time the Signal is updated, the function <code>f</code> runs.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L154">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.unsubscribe!-Tuple{Any,ReactiveBasics.Signal}" href="#ReactiveBasics.unsubscribe!-Tuple{Any,ReactiveBasics.Signal}"><code>ReactiveBasics.unsubscribe!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">unsubscribe!(f, u)
</code></pre><p>Unsubscribe to the changes of this Signal.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.value-Tuple{ReactiveBasics.Signal}" href="#ReactiveBasics.value-Tuple{ReactiveBasics.Signal}"><code>ReactiveBasics.value</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">value(u)
</code></pre><p>The current value of the Signal <code>u</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L54">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ReactiveBasics.zipmap-Tuple{Any,ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}" href="#ReactiveBasics.zipmap-Tuple{Any,ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>ReactiveBasics.zipmap</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">zipmap(f, u, us; init, typ)
</code></pre><p>Zips given signals first and then applies the <code>map</code> function onto the zipped value. This omits the double calculation when using <code>map</code>. The initial value of the output Signal can optionally be set via <code>init</code>. Otherwise it defaults to <code>f(zip(u, us...).value...)</code>, where f is the passed function and (u, us...) are the passed Signals. The type of the output Signal can optionally be set via <code>typ</code>. Otherwise it defaults to the type of the initial value.</p><pre><code class="language-none">as = Signal(1)
bs = map(a -&gt; a * 0.1, as)
cs = zipmap((a,b) -&gt; a + b, as, bs) # This calculation is done once for
                                    # every change in `as`</code></pre></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L122">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Iterators.zip-Tuple{ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}" href="#Base.Iterators.zip-Tuple{ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>Base.Iterators.zip</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">zip(u, us)
</code></pre><p>Zip (combine) Signals into the current Signal. The value of the Signal is a Tuple of the values of the contained Signals.</p><pre><code class="language-none">signal = zip(Signal(&quot;Hello&quot;), Signal(&quot;World&quot;))
value(signal)    # (&quot;Hello&quot;, &quot;World&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L174">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.asyncmap-Tuple{Any,Any,ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}" href="#Base.asyncmap-Tuple{Any,Any,ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>Base.asyncmap</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">asyncmap(f, init, input, inputs; typ)
</code></pre><p>An asynchronous version of <code>map</code> that returns a Signal that is updated after <code>f</code> operates asynchronously. The initial value of the returned Signal (the <code>init</code> arg) must be supplied. The type of the output Signal can optionally be set via <code>typ</code>. Otherwise it defaults to the type of the initial value.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L255">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter-Union{Tuple{T}, Tuple{Any,T,ReactiveBasics.Signal{T}}} where T" href="#Base.filter-Union{Tuple{T}, Tuple{Any,T,ReactiveBasics.Signal{T}}} where T"><code>Base.filter</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Return a Signal that updates based on the Signal <code>u</code> if <code>f(value(u))</code> evaluates to <code>true</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L233-L235">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,ReactiveBasics.Signal}" href="#Base.map-Tuple{Any,ReactiveBasics.Signal}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">map(f, u; init, typ)
</code></pre><p>Transform the Signal into another Signal using a function. The initial value of the output Signal can optionally be set via <code>init</code>. Otherwise it defaults to <code>f(u.value)</code>, where f is the passed function and u is the passed Signal. The type of the output Signal can optionally be set via <code>typ</code>. Otherwise it defaults to the type of the initial value.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L61">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge-Tuple{ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}" href="#Base.merge-Tuple{ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">merge(u, us)
</code></pre><p>Merge Signals into the current Signal. The value of the Signal is that from the most recent update.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L200">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{ReactiveBasics.Signal,Any}" href="#Base.push!-Tuple{ReactiveBasics.Signal,Any}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">push!(u, val)
</code></pre><p>Update the value of a Signal and propagate the change.</p></div><a class="source-link" target="_blank" href="https://github.com/tshort/ReactiveBasics.jl/tree/5d1a449e42618aada195f8482d32cf1978651944/src/ReactiveBasics.jl#L144">source</a><br/></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
