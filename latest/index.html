<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ReactiveBasics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ReactiveBasics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Change-propagation-1">Change propagation</a></li><li><a class="toctext" href="#Handling-asynchronous-Signals-1">Handling asynchronous Signals</a></li><li><a class="toctext" href="#Other-notes-1">Other notes</a></li></ul></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/tshort/ReactiveBasics.jl/tree/93e4042c8aa2e3f2ddbf7b78c939fc51989d0d6e/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ReactiveBasics-1" href="#ReactiveBasics-1">ReactiveBasics</a></h1><p>This package implements basic functionality for a type of Functional Reactive Programming (FRP).  This is a style of DataFlow programming where updates propagate to other objects automatically. It follows the same basic API as <a href="http://juliagizmos.github.io/Reactive.jl/">Reactive.jl</a>. Much of the <a href="http://juliagizmos.github.io/Reactive.jl/">documentation for Reactive</a> applies to ReactiveBasics.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>The <code>Signal</code> type holds values that can depend on other <code>Signal</code>s.  <code>map(f, xs...)</code> returns a new Signal that depends on one or more Signals <code>xs...</code>.  The function <code>f</code> defines the value that the Signal should take as a function of the values of each of the input Signals.  When a <code>Signal</code> is updated using <code>push!</code>, changes propagate to dependent <code>Signal</code>s.  Here is an example taken from Reactive.jl:</p><pre><code class="language-julia-repl">julia&gt; using ReactiveBasics

julia&gt; x = Signal(0)
ReactiveBasics.Signal{Int64}(0, Function[])

julia&gt; value(x)
0

julia&gt; push!(x, 42)

julia&gt; value(x)
42

julia&gt; xsquared = map(a -&gt; a*a, x)
ReactiveBasics.Signal{Int64}(1764, Function[])

julia&gt; value(xsquared)
1764

julia&gt; push!(x, 3)

julia&gt; value(xsquared)
9</code></pre><p>Various utility functions are available to manipulate signals, including:</p><ul><li><p><a href="api.html#ReactiveBasics.subscribe!-Tuple{Any,ReactiveBasics.Signal}"><code>subscribe!</code></a> – Subscribe to the changes of a Signal. </p></li><li><p><a href="api.html#Base.merge-Tuple{ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>merge</code></a> – Combine Signals.</p></li><li><p><a href="api.html#Base.Iterators.zip-Tuple{ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>zip</code></a> – Combine Signals as a Tuple.</p></li><li><p><a href="api.html#ReactiveBasics.zipmap-Tuple{Any,ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>zipmap</code></a> – Zip then map.</p></li><li><p><a href="api.html#Base.filter-Union{Tuple{T}, Tuple{Any,T,ReactiveBasics.Signal{T}}} where T"><code>filter</code></a> – A Signal filtered based on a function.</p></li><li><p><a href="api.html#ReactiveBasics.filterwhen-Union{Tuple{T}, Tuple{ReactiveBasics.Signal{Bool},T,ReactiveBasics.Signal{T}}} where T"><code>filterwhen</code></a> – A Signal filtered based on a Signal.</p></li><li><p><a href="api.html#ReactiveBasics.foldp-Tuple{Any,Any,Vararg{ReactiveBasics.Signal,N} where N}"><code>foldp</code></a> – Fold/map over past values.</p></li><li><p><a href="api.html#ReactiveBasics.flatmap-Tuple{Any,ReactiveBasics.Signal}"><code>flatmap</code></a> – Like <code>map</code>, but it&#39;s meant for functions that return <code>Signal</code>s.</p></li><li><p><a href="api.html#Base.asyncmap-Tuple{Any,Any,ReactiveBasics.Signal,Vararg{ReactiveBasics.Signal,N} where N}"><code>asyncmap</code></a> – Like <code>map</code>, but it updates asynchronously.</p></li><li><p><a href="@def"><code>flatten</code></a> – Flatten a Signal of Signals.</p></li><li><p><a href="@def"><code>bind!</code></a> – Bind two Signals, so that updates to one are synchronized with the other.</p></li><li><p><a href="@def"><code>droprepeats</code></a> – Drop repeats in the input Signal.</p></li><li><p><a href="@def"><code>previous</code></a> – A Signal with the previous value of the input Signal.</p></li><li><p><a href="@def"><code>sampleon</code></a> – Sample one Signal when another changes.</p></li><li><p><a href="@def"><code>preserve</code></a> – No-op for compatibility with Reactive.</p></li></ul><h2><a class="nav-anchor" id="Change-propagation-1" href="#Change-propagation-1">Change propagation</a></h2><p>The main difference between ReactiveBasics and Reactive.jl is that Signals propagate immediately  (synchronous operation) in ReactiveBasics. There is no event queue. The implementation uses closures derived from the approach used in the Swift package  <a href="https://github.com/JensRavens/Interstellar">Interstellar</a>. The difference in operation makes ReactiveBasics as much as ten times faster than Reactive.  But, because ReactiveBasics is synchronous, this leads to limitations. One is that there  can be race conditions for asynchronous inputs. Those have to be manually handled. Another  issue is that calculations can be triggered twice if there are mutual dependencies.</p><p>ReactiveBasics uses <a href="https://en.wikipedia.org/wiki/Reactive_programming#Change_Propagation_Algorithms">push-style</a>  reactive programming. When <code>push!</code> is used to update a signal, dependencies of this Signal  update in depth-first fashion. </p><p>Here is an example that leads to double calculations:</p><div><pre><code class="language-julia">using ReactiveBasics
x = Signal(2)
x2 = map(u -&gt; 2u, x)
y = map(+, x2, x)
subscribe!(u -&gt; println(&quot;value of y: $u&quot;), y)
push!(x, 3)</code></pre><pre><code class="language-none">value of y: 9
value of y: 9</code></pre></div><p>This <code>push!</code> will trigger <code>y</code> to update twice. The update to <code>x</code> triggers the update to <code>x2</code>. The update to <code>x2</code> triggers the update to <code>y</code>. But because <code>y</code> also depends on <code>x</code>, it updates a second time.  Both times, the resulting value for <code>y</code> is right, but this effect will be important if a Signal accumulates or otherwise depends on history or the number of calculations.</p><h2><a class="nav-anchor" id="Handling-asynchronous-Signals-1" href="#Handling-asynchronous-Signals-1">Handling asynchronous Signals</a></h2><p>Even though ReactiveBasics uses direct, push-style processing, it is possible to handle asynchronous Signals. For long calculations or for input/output, it&#39;s often convenient to return a Signal with the end result rather than just a value.  That allows updates to propagate correctly.  <code>flatmap</code> is a useful utility for managing operations that return Signals.  See the <a href="https://github.com/tshort/ReactiveBasics.jl/blob/master/examples/space-station.jl">space-station example</a>  by GitHub user <a href="https://github.com/nixterrimus">nixterrimus</a>.</p><p>Another way to handle asynchronous Signals is to set up a queue of Signals.  See <a href="https://github.com/tshort/ReactiveBasics.jl/blob/master/examples/shashi-race-condition.jl">this example</a>. </p><h2><a class="nav-anchor" id="Other-notes-1" href="#Other-notes-1">Other notes</a></h2><p>This is a basic implementation. There is no support for error checking, time, or sampling. My main use case is with <a href="https://github.com/tshort/Sims.jl">Sims</a>, and that doesn&#39;t need a lot of features.</p><footer><hr/><a class="next" href="api.html"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
